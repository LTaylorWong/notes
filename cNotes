9/11/15
scp-secure copy
to copy foo.c from one computer to the other in the /code/ directory
scp foo.c username@homer.stuy.edu:/code/

List java primitive types:
	-int 		32 bit integer
	-boolean	true/false 
	-char		single character
	-long		64 bit integer
	-double		64 bit floating point number
	-float		32 bit floating point number
	-byte		8 bit integer
	-short		16 bit integer

------------------------------------------------------
9/16/15
Aim: Variables are the spice of life
Do now: What is the smallest variable type that could be used to store 
the following values (using standard sizes)
1)5		byte
2)-30,000	short
3)255		short
4)5,000,000,000	long

byte: -128--->127 (-2^7--->-2^7 -1)
short: -2^15---> 2^15 -1
int: -2^31 ---> 2^31 -1
long: -2^63 ---> 2^63 -1

C primitive variable types:
	All C primitives are numeric
	
	The only difference is floating point vs. integer and size of variable.
	
	Size can be platform dependent
		sizeof(<TYPE>) can be used to find the size in bytes
		sizeof(int)

	Type		Standard Size(in bytes)
	int			4
	short			2
	long			8	
	float			4
	double			8
	char			1

	All boolean values are numbers
		0 ==> false
		anything else ==> true

	Data Types and Variables:
		Character literals are single characters inside ' '
			ex. 'a', '*' etc....
		String literals exists, even though there is no String date type
			ex. "hello", "you smell"

		Variables cannot be declared in for loop statements
		but they can be initialized.
-------------------------------------------------------------
9/17/15
Aim: Always read the fine print
Do Now: Open up your editor choice(emacs)
	write basic "Hello World" program in Java 	

	(cont. from yesterday)
	Any variable type can be declared an "unsigned" variable
	this signifies the variable will never be negative
		the lower bound of any unsigned variable is 0
		the upper bound will be greater than the signed version
		ex. 	unsigned char x
			0<=x<=255
	#include: C version of import
	compiling/nameing c files: gcc <file name> -o "<name>"
-------------------------------------------------------------
9/18/15
Aim: A vast array of possiblities
Do now: How do you declare/use arrays in java

	C files: full code
	h files: header, function headers, constants/globals

	PATH: location of known exectuabl programs
	
	printf
		The most important function!!!!!
		Prints formatted strings
		printf(<string literal>, <var1>, <var2>.....)
	Simple printf does not need <var> arguments.
	printf does not add a new line

	 printf("bob = %f\n", bob); %f:place holder for floating point number

	FORMATTING PLACE HOLDERS
	Type		Char
	int		%d
	long		%ld
	float		%f
	double		%lf
			%0.<x>f will provide x digits after the floating point
	char		%c
	char array	%s
	pointer		%p
-------------------------------------------------------------
9/22/15
Aim: What's the point of it all?
Memory Management
	Memory allocation either happens at compile time 
	or at run time (dynamic)
Compiler Allocated Memory
	Packaged with the binary of the program
	
	***There is no standard default value***

	Varibles and arrays are allocated here
		ex. float a	int b[5]
	Arrays
		Arrays are NOT  dynamic
		Must have a fixed size
		There is no length function
		No boundary checking
----------------------------------------------------------
9/25/15
Aim: Now really getting to the point.
	
	Pointers-
		Variables designed to store memory
		addresses (think references in java)
	[	
	 int fred;     fred address = 1000
	 fred = 86; ---> 1000(address) = 86
	]
	[
	 int *pfred; 		fred pointer
	 pfred address = 2020
	 if give pfred value 1000, points to fred
	]
	
	& 	give address operator
	* 	is used to declare a variables as a pointer type
		ex. int *p, double *q, char *r..... 

	all pointers are the same size
----------------------------------------------------------
9/28/15
Aim: Really REALLY getting to the point
	Do now:
		1)declare int, double, and char variables
		2)declare int, double, and char pointers
		3)Initialize each pointer to the address of the
		  correpsonding variable
		4)Print out the pointer's value for each (as
		  an assigned long)
		5)Add 1 to each pointer
		6)Print out pointers again

	*	also used as the de-reference opperator
			It accesses the value at the memory location
			stored in the pointer

	Pointer arithmetic
		int *p = &i;
		char *c = &i;
		
		p++; //will add 4 to p
		c++; //will add 1 to p
	
	Array variables are immutable pointers

	Pointers can be assigned to array variables
		int ray[5];
		int *rp = ray;
	
		ray[3] <=> ?
			   *(rp+3)

	a[i] notation is shorthand for *(a+i)

	a[i] = i[a] 
------------------------------------------------------------
9/29/15
Aim: Time to stop Stringing you along
	
	float fray[5];
	float *fp = fray

	fp------> fray|2.3|2  |81.7|.21|5|
		       824 828 832	
	fp = 824
	*fp = 2.3

	fp + 2 ---> 832
	*fp + 2 ---> 4.3
	*(fp + 2) ---> 81.7
	fp[2] = 81.7
	fray[2] = 81.7

	Cstrings
		Strings are charcter arrays that end with a null
		character (either '' or 0 or '\0')
		STRING FUNCTION WILL NOT WORK WITHOUT THE TERMINATING NULL

	WAYS TO DELCARE STRINGS:
		char s[256];
			Normal array declaration, allocates 256 bytes
			but nothing is set automatically

		char s[256] = "Imagine";
			Allocates 256 bytes, pit "Imagine" in the first 
			7 bytes AND add null at the 8th byte.
	

		char s[] = "Tuesday";
			Allocates 8 bytes, and puts "Tuesday" in the first
			7 bytes AND add null at the 8th byte.
		char *s = "Mankind";
			Allocates 8 bytes, and puts "Tuesday" in the first
			7 bytes AND add null at the 8th byte. s is a pointer
			variable instead of an array. 		
			
		You can only assign strings with = at declaration
			char s[] = "zero" //ok
			s = "seven"        //not ok
------------------------------------------------------------------------
9/30/15
Aim: Writing fuctioning code
Do now: write a program to do the following:
	1)Create a string and set it to some value
	2)Find it's length

	All c functions are "pass by value"
		a parameter is a copy of the variable passed into 
		the function. The original varaible is not touched.

	fuction headers
		<return type> name (<parameters>)
---------------------------------------------------------------------
10/1/15
	You must declare a function before you can use it (like netlogo)

	1) write entire code in correct order
	2)write the fuction headers at the to of your code, 
		and the provide full definition later
	3)put all function headers in a .h file, then include 
		in the .c file

	string.h
		C library that includes useful string functions
		
		All the fuctions assume that the parameter strings are always 
		null-terminating

	int strlen(char *s)
		returns the number of characters form the start of s up to
		but not including the null
	int strcmp (char *s1, char *s2)
`		returns 0 if s1 and s2 are identical
		returns a positive number if s1 is greater thatn s2
	`	returns a negative number if it is less
	char * strcpy (char *dest, char *source)
		copies all the characters up to and including the null
		returns dest
	chat * strcat(char *s1, char *s2)
		appends the characters up to and including the terminating
		null in s2 at the end of s1
		returns s1
	Many string functions have a "strn" version, these take an extra
	parameter that set a limit to the number of bytes you will look 
	at in a string
----------------------------------------------------------------------
10/6/15
separate compilation
	you can combine multiple c files inta a c program be including
	them all in gcc command
	
	you cannot have duplicate functions or global variable names
	across these files.
	this includes the main() function.
---------------------------------------------------------------------
10/07/15

gcc -c :only compilies, does not create executable file
creates .o file, do with .c files with no main() function
file: tell you what type of file it is
gcc can link .o and .c files together

Make
	creates compiling instrusctions and setting up dependencies

	looks at your time stamps and will deternmine if it needs
	to be updated

TARGET:dependencies
TAB	<rules>
ex. a.out: main.c dwstring.o
	   gcc main.c dwstring.o
dwstring.o: dwstring.h dwstring.c
	    gcc -c dwstring.c
------------------------------------------------------------------
10/08/15
Aim: if you cant (al)locate your memory...i forget

Dynamic memory allocation
	malloc(int x)
		Allocates x bytes of memory (from the heap)
		
		Returns the address at the begining of allocation
		
		Returns a void *, always typecast to the correct 
		pointer type	 	

		int *p;
		p = (int *)malloc(5 * sizeOf(int));

	calloc(int n, int x)
		Allocates n * x bytes of memory

		Ensures that each bit is set to 0

		Works like malloc in all other ways

		int *p;
		p = (int *)calloc(5, sizeOf(int));

	realloc(void *p, int x)
		Changes the amount of memory allocated to a given 
		block

		p must be a pointer to the beginning of an 
		allocated block of memory, but it does not have to 
		be the original pointer.

		If x is smaller than the original size of the 
		allocation, the extra bytes will be released

		If x is larger than the orginal size of the 
		allocation the extra bytes will be released.



	free 
		released dyanamiclly allocated memory

		takes one parameter

		every time you call malloc/calloc,
		must have a corresponding free call
-------------------------------------------------------------
10-09

-put struct def in header file
typedef struct n{
	int i;
	struct n *next;
	} node; 
-------------------------------------------------------------
10-13
ZELDA'S IN TROUBLE, GET LINK!

if you want to use a struct within its owe declaration, you must prototype it first

c uses snake case

when memory is not allocated dyanimically it is put on the stack, therefore it will go away after function is done.
--------------------------------------------------------------------
10-15
HOW TO DEAL WITH HEADER FILES WITH INTER-DEPENDENCIES

#define
	to find and replace
ex:
	#define foo 27
	//whereever foo is used, it will be replaced by 27 NO MATTER WHAT
	//VALUE CANNOT BE CHANGED

#ifndef (if not defined)
	STUFF HAPPENS
#endif

ex:
	#ifndef foo (if foo is not defined)
----------------------------------------------------------
10-20
Aim: File this under useful information

Do Now: What are different kind of file permissions?
read, write, excute
using Rand- if constantly running, will get the same number because starting with the same input
srand()
rand()
sranddev()

there are 3 permission "areas"
	user, group, others

	each area can have its own permissions:
	read, write, execute
	
	644-> user:read & write, group: read, other: read

chmod: change mode (to change the permissions)
the owner of the file always has the power
-----------------------------------------------
Note: Dont compile .h files!
SOTD: Everything- MrNorth

Aim: Opening the whole new world of possibilities
File Table:
	A list of all files used by a program whiles its running.

	Contains basic information like the file's location and size

	The file table has a limited size, which is a power of 2
	and commonly 256. getdtablesize() will return this value.

		File Table
FD	Name(Path)		Location
	---------------------------------
0	foo			blah
1	output
2	input

	Each file is given an integer index, starting at 0, this is 
	refered to as the file descriptor

	THere are 3 files that are always open in the table
	0 or STDIN_FILENO: stdin
	1 or STDOUT_FILENO: stdout
	2 or STDERR_FILENO: stderr

open - <fcntl.h>
	add a file to ht efile table and returns the file descriptor
	if open fails, -1 returned, extra error info can be found in errno

	errno
		found in <errno.h>
		gives you error number
	sterror
		tells you whats actually wrong

	open(<PATH>, <FLAGS>, <MODE>)
	
	mode
		only used when you make a new file, it is the permissions
		of the new file, must be a 3 didgit octal number

		octal numbers have a leading 0
		0644, 0744.....	

	FLAGS
		determine what you plan to do with the file

		o_rdonly
		o_wronly
		o_rdwr
		o_append
		o_trunc
		o_creat
		o_excl: only works in combo with create, error will return if
			you try to create a file that already exists
---------------------------------------------------------------------
10-22
Song of the Day: Fly me to the moon- Frank Sinatra
AIM: READ YOUR WRITES

Flag Stuff ex:
EXCL(2048)	TRUNC(1024)	CREAT(512)	APPEND(8)	RDWR(2)		WRONLY(1)	RDONLY(0)
0		0		1		0		0		0		0
1		0		0		0		0		0		0
0		0		0		0		0		1		0

bitwise operators
	&: and
	|: or
	~: not
	^: xor
	logical opperators work on each indiviual bit of a value

	char c = 13; //00001101
	char x = ~c; //11110010

flags
	each flag is a number, to combine flags we use bitwise or

	wronly = 1 00000001
	append = 8 00001000
	wronly|append = 00001001

close - <unistd.h>
	remove a file from file table
	returns 0 if sucessfull. returns -1 and set errno if not sucessful
close(<FILE DESCRIPTOR>)

read- <unistd.h>
	read data in file
	read(<FILE DESCRIPTOR>, <BUFFER>, <AMOUNT>)
	read(fd, buff,n)
	amount-based on the size of buffer
	read n bytes from the fd's file and put that data into buff
	returns the number of bytes actually read
	returns -1 and sets errno if not
	
	BUFFER must be a pointer

write- 
	write data to a file
	write(<FILE DESCRIPTOR>, <BUFFER>, <AMOUNT>)
	write(fd, buff,n)
	amount-based on the size of buffer
	write n bytes from the fd's file and put that data into buff
	returns the number of bytes actually written
	returns -1 and sets errno if not
	
	BUFFER MUST BE A POINTER
--------------------------------------------------------
10-26
umask 
	shuts off certain permissions

	is applied by using bitwise negation on the mask
	then bitwise adding to the mose
		new_permissions = ~mask & mode
	default mask is 022
	shuts off write for group and other

lseek
	set the current position in an open file

	lseek(<FILE DESCRIPTOR>,<OFFSET>,<WHENCE>)
	WHENCE-position you are measuring the offset from
	OFFSET- number of bytes to move the position by
----------------------------------------------------------
10-28
aim: i need information, stat!

Do Now: 
	1)Make a Directory
	2)Put a few files in that directory and maybe a directory or two

stat- <sys/stat.h>
	Get information about a file(metadata)
	
	stat(<PATH>, <STAT BUFFER>)

		struct stat sb;
		stat("foo", &sb);

	stat buffer
	
	Must be a buffer to a struct stat

	All the file information gets put into the stat buffer

	Some of the fields in the struct stat:
		st_size
			file size in bytes
		st_uid, st_gid
			user id, group id
		st_mode
			file permissions
		st_atime, st_mtime
			last access, last modification
			These are struct time_t variables. We can use
			functions in time.h to make sense of them

		ctime(<TIME>)
			TIME is the type time_t *
			returns time struct as a string
			has to be a pointer
		time(<TIME>)
			TIME is the type time_t *
			sets a parameter to the current time
--------------------------------------------------------
10-29

Directories	
	a *nix directory i  file contatining the names of the riles within the directory.
	along iwth basic information like file type.

	Moving files into/out of a directory means changing the 
	directory file, not actually moving the data

opendir-<dirent.h>	
	open a director file	

	This will not change the cwd, it only allows your program
	to read the contents of the directory file.

	opendir(<PATH>);
		
	Returns a pointer to a directory stream (DIR *)

readdir - <dirent.h>
	readdir(<DIRECTORY STREAM>)
	
	Returns a pointer to the entry in a directory steam,
	or NULL is all the entries have already been returned.

	struct dirent - <sys/types.h>
		Directory struct that contains the information 
		stored in a directory files.

		Some of the data members

		d_name: Name of file
		d_type:	File type as int

