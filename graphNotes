2-3
Image file formats

COMPRESSED        vs       UNCOMPRESSED
-smaller	       	   -full map of pixel values
-often less info
PNG			   bmp
JPEG/JPG                   tiff
GIF                        svg
			   raw

LOSSY             vs       LOSSLESS
-loses			   -contains all			
some of the 		   the original info
original info
JPEG			   bmp
			   tiff
			   PNG

RASTER	          vs	   VECTOR
represts image		   image is represented
as a grid of               as a list of drawing
pixel                      instructions
			   scale well
			   svg


netpbm
-rastor
-losses
-uncompressed

{HEADER}
[P3
XRES YRES (dimensions)
MAX_COLOR_VAL]
R G B R G B.... 
-------------------------------------------------------
2-5
Bresenhams' line alogorithm

0=Ax+By+ C
A = deltaY
B = -deltaX
C = (deltaX)b
---------------------------------------------------------
2-9
***OCTANT UNO***
(x,y)-->(x+1,y) or(x+1,y+1)
mp = (x+1,y+.5)
f(x+1,y+.5),
=0: on the line, draw either pixel
<0: above the line, draw lower pixel (x+1,y)
>0: below the line, draw higher pixel (x+1,y+1)

FIRST DRAFT:
	(x0,y0)-->(x1,y1)
	x=x0 y=y0
	while(x<=x1)
	   plot(x,y)
	   d = f(x+1,y+.5)
	   if(d>0)
		y+=1
	   x+=1

initial value of d: 
f(x0+1,y0+.5)
d = A(x0+1)+B(y0+.5)+C
d = Ax0 + A + By0 + .5B + C
d = 0 + A + .5B
d = A + .5B

SECOND DRAFT:
	(x0,y0)-->(x1,y1)
	x=x0 y=y0
	d = A + .5B
	while(x<=x1)
	   plot(x,y)
	   if(d>0)
		y+=1
	   x+=1
	d = f(x+1,y+.5)

if d < 0
x-->x+1 y-->y
f(x+1,y)
d = A(x+1)+By+C
d = Ax + A + By + C
d = d + A

if d > 0 
x-->x+1 y-->y+1
f(x+1,y+1)
d = A(x+1)+B(y+1)+C
d = Ax + A + By + B + C
d = d + A + B

THIRD DRAFT:	
	(x0,y0)-->(x1,y1)
	x=x0 y=y0
	A = y1-y0 B = -(x1-x0)
	d = A + .5B
	while(x<=x1)
	   plot(x,y)
	   if(d>0)
		y+=1
		d+=B
	   x+=1
	   d+=A
---------------------------------------------------------
2-10
FOURTH DRAFT:	
	(x0,y0)-->(x1,y1)
	x=x0 y=y0
	A = y1-y0 B = -(x1-x0)
	d = 2A + B
	while(x<=x1)
	   plot(x,y)
	   if(d>0)
		y+=1
		d+=2B
	   x+=1
	   d+=2A

***OCTANT DOS***
1<m
(x,y+1)
(x+1,y+1)
mp(x+.5, y+1)
Ax + By + c + .5A + B
d = .5A+B
	
if d < 0: (x,y) to the left
if d > 0: (x,y) to the right

	(x0,y0)-->(x1,y1)
	x=x0 y=y0
	A = y1-y0 B = -(x1-x0)
	d = A + 2B
	while(y<=y1)
	   plot(x,y)
	   if(d<0)
		x+=1
		d+=2A
	   y+=1
	   d+=2B

octant 1 & 5 same
Octant 2 & 6 same
octant 3 & 7 same
octant 4 & 8 same

octant 8
-1 < m < 0
(x+1,y)
(x+1,y-1)
mp(x+.5, y++1)
-----------------------------------
LOOK @ DWSOURCE
struct point_t{
int red
int green
int blue
}point_t;

typedef struct point_t color;
typedef struct point_t screen[x][y];
--------------------------------------
2-22
USING MATRICES

Point matrix

while(i<points.length-2)
	draw-line(points[i],points[i+1])
	i+=2

edges = new_matrix()
addedge(edges, p0,p1)
....
draw_edges(edges)
----------------------------------
2-23
woooo matrix math review

scalar multiplication
-distribute the scalar to the matrix

matrix multiplication
-not communitive
-columns1 must equal rows2
AxB * BxC = AxC


(a+2b+3c),(4a+5b+6c)
(d+2e+3f),(4d+5e+6f)
(g+2h+3i),(4g+5h+6i)

Multiplicative identity matrix
-square
-diagonals are all 1, all others 0
--------------------------------------
2-24

Scaling
(x,y,z)---S(a,b,c)--->(ax,by,cz)

Translating
(x,y,z)---T(a,b,c)--->(x+a,y+b,z+c)
|100a|
|010b|
|001c|
|0001|

Rotating
(x,y,z)---R(z,thetha)--->(xcos(theta)-ysin(theta),xsin(theta)+ycos(theta),z)
|cos(theta) -sin(theta) 0 0|
|sin(theta) cos(theta)  0 0|
|0            0         1 0|
|0            0         0 1|

(x,y,z)---R(x,theta)--->(x,ycos(theta)-zsin(theta),ysin(theta)+zcos(theta))
|1            0         0        0|
|0       cos(theta) -sin(theta)  0|
|0       sin(theta) cos(theta)   0|
|0            0         0        1|

(x,y,z)---R(y,theta)--->(xcos(theta)-zsin(theta),y,xsin(theta)+zcos(theta))
|cos(theta)   0    -sin(theta)   0|
|0            1         0        0|
|sin(theta)   0     cos(theta)   0|
|0            0         0        1|
-----------------------------------------------------------------------------
2-25
Applying transformations
E0: Edge Matrix 
T: Translate Matrix
S: Scale Matrix
R: Rotation Matrix

T*E0 = E1 [translated]
S*E1 = E2 [translated then scaled]
R*E2 = E3 [translated then scaled then rotated]
E3 = (R*S*T)*E0
--------------------------------------
3-7
Parametric Equations

x = f(t)
y = g(t)
t: 0 --> 1

Line:
(X0,Y0)-->(X1,Y1)
f(t)=X0+ t(deltaX)

---------------------------------
3-8
Hermite Curve

INPUTS
p0,p1: endpoints
r0,r1: rates of change at each endopoint

f(t) = at^3 + bt^2 + ct + d : points on the curve
f'(t) = 3at^2 + 2bt + c : rates of change

when t = 0
	f(t) = d  : p0
	f'(t) = c : r0

when t = 1
	f(t) = a + b + c + d : p1 
	f'(t) = 3a + 2b + c : r1
---------------------------------------
3-9
INPUTS
p0,p1 \
r0,r1 /    = at^3 + bt^2 + ct + d

[0001] [a]   [d      ]   [p0]
[1111] [b]   [a+b+c+d]   [p1]
[0010] [c] = [c      ] = [r0]
[3210] [d]   [3a+2b+c]   [r1]

Bezier Curve

Inputs:
p0 , p3: endpoints
p1 , p2: other points

when you add a degree you add an extra input

p(t) = (1-t)p0 + t(p1)


QUADRATICS:
r(t) = (1-t)r0 + t(r1)
r0(t) = (1-t)p0 + t(p1)
r1(t) = (1-t)p1 + t(p2)


R(t) = (1-t)^2 p0 + 2t(1-t)(p1) + t^2(p2)

CUBIC:
Q(t)= (1-t)r0 + t(r1)

Q(t) = (1-t)^3 p0 + 3t(1-t)^2(p1) + 3t^2(1-t)(p2) + t^3(p3)




  a = (-p0+3p1-3p2+p3)t^3
  b = (3p0-6p1+3p2)t^2
  c = (-3p0+3p1)t
  d = (p0)

[-1 3 -3 1]
[3 -6  3 0]
[-3 3  0 0]
[1  0  0 0]

t(t(at + b)+c)+d

3M 3A

-------------------------------------
3-21 -> 3-22
3D Shapes

Box, Sphere, torus, bezier/hermite surfaces

BOX:
input: width, height, depth, (x,y,z)[upper/left/front corner]

SPHERE:
input: 
[1  0    0  0]     [rcos(theta)]    x = rcos(theta)
[0 cos -sin 0]     [rsin(theta)]    y = rsin(theta)cos(fi) 
[0 sin cos  0]  x  [    0      ] =  z = rsin(theta)sin(fi)
[0  0   0   1]     [    1      ]   

theta = angle of circle creation
fi = angle of circle rotation

if theta: 0->2pi
      fi: 0->pi

if theta: 0->pi
      fi: 0->2pi 

for p: 0->1
	for t: 0->1
   	    x = rcos(piT)
	    y = rsin(piT)cos(2piP)	
	    z = rsin(piT)sin(2piP)

TORUS:

[1  0    0  0]     [rcos(theta)    ]    x = rcos(theta)
[0 cos -sin 0]     [rsin(theta) + R]    y = rsin(theta + R)cos(fi) 
[0 sin cos  0]  x  [    0          ] =  z = rsin(theta + R)sin(fi)
[0  0   0   1]     [    1          ]   

      theta: 0->2pi
      fi: 0->2pi
---------------------------------------
3-29
Wire Frame/Polygon Meshes

WIREFRAME
3D object defined by the edges that connect the vertices/points
Uses the same edge matrix concepts

POLYGON
3D obeject is defined by the surfaces(typically triangle or quadralateral)
that cover the object
Change the edge matrix--->polygon matrix
Allows us to draw solid objects and remove hidden surfaces

POLYGON MATRIX
PM = [[p0,p1,p2],[p2,p3,p0],...]

EM		PM
plot----------->plot
drawLine------>drawLine
drawLines---->drawPolygons
addPoint------>addPoint
addEdge------>addPolygon (add the points counterclockwise)
-------------------------------------------------
3-30
Polygon Meshes
----------------------------------------------
4-5
Backface Culling
Not render and any backwards facing surfaces.
The surface normal(N) is a vector perpendicular to a plane
We compare the N to the view vector(camera)(V) 90<theta<270
CALCULATING SURFACE NORMAL
cross prodect of 2 vectors that share an endpoint,
and go in differenct directions.
------------------------------------------
4-6
STEP 1: CALCULATING SURFACE NORMAL
STEP 2: FIND THETA(between surface normal and view vector)
STEP 3: IF 90<theta<270, THEN DRAW POLYGON

STEP ONE:
<AyBz-AzBy,AzBx-AxBz,AxBy-AyBx>

STEP TWO:
(looking straight at the screen) view vector <0,0,-1>
(N)x(V) = __cos(theta)
if cos(theta) < 0 then 90<theta<270
= NxVx+NyVy+NzVz
-----------------------------------------------
4-12
Relative Coordinate System
-Currently all of our objects are drawm w respect to the same origin/coordinate system (Global Coordinate System)
-Each object could have its own coordinate system, each object could have its own origin/coordinate system (relative Coordinate System)
-We will use a STACK to store the coordinate systems

DRAWING FRAMEWORK
	A.Transformations are applied to the current top of the stack
	B.The stack is pushed and popped as need be
	C.Drawing Pipeline
		1.Generate the points/polygons and add them to a matrix
		2.multiply points by current top of the stack
		3.Draw the points to the screen
		4.Clear point matrix
	
